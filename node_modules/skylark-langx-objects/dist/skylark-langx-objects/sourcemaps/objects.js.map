{"version":3,"sources":["objects.js"],"names":["define","skylark","_attach","types","eq","deepEq","hasOwnProperty","Object","prototype","slice","Array","isBoolean","isFunction","isObject","isPlainObject","isArray","isArrayLike","isString","toInteger","keysFunc","defaults","SymbolProto","Symbol","allKeys","obj","keys","key","push","has","path","call","length","i","_mixin","target","source","deep","safe","undefined","_parseMixinArgs","args","params","arguments","shift","pop","sources","mixin","apply","this","forEach","values","a","b","aStack","bStack","type","className","toString","valueOf","areArrays","aCtor","constructor","bCtor","attach","clone","src","checkCloneMethod","copy","index","l","each","callback","isForEach","value","undef","extend","arg","isEqual","includes","collection","fromIndex","guard","nativeMax","indexOf","baseIndexOf","isMatch","object","attrs","omit","prop1","prop2","result","pn","pick","removeItem","items","item","idx","splice","fallback","split","prop","safeMixin"],"mappings":"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","file":"../objects.js","sourcesContent":["define([\r\n    \"skylark-langx-ns/ns\",\r\n    \"skylark-langx-ns/_attach\",\r\n\t\"skylark-langx-types\"\r\n],function(skylark,_attach,types){\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\r\n        slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean,\r\n        isFunction = types.isFunction,\r\n\t\tisObject = types.isObject,\r\n\t\tisPlainObject = types.isPlainObject,\r\n\t\tisArray = types.isArray,\r\n        isArrayLike = types.isArrayLike,\r\n        isString = types.isString,\r\n        toInteger = types.toInteger;\r\n\r\n     // An internal function for creating assigner functions.\r\n    function createAssigner(keysFunc, defaults) {\r\n        return function(obj) {\r\n          var length = arguments.length;\r\n          if (defaults) obj = Object(obj);  \r\n          if (length < 2 || obj == null) return obj;\r\n          for (var index = 1; index < length; index++) {\r\n            var source = arguments[index],\r\n                keys = keysFunc(source),\r\n                l = keys.length;\r\n            for (var i = 0; i < l; i++) {\r\n              var key = keys[i];\r\n              if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n            }\r\n          }\r\n          return obj;\r\n       };\r\n    }\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function each(obj, callback,isForEach) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function has(obj, path) {\r\n        if (!isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n            if (deep && isPlainObject(source[key])) {\r\n                if (!isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                //if (isArray(source[key]) && !isArray(target[key])) {\r\n                //    target[key] = [];\r\n                //}\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function removeItem(items, item) {\r\n        if (isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function result(obj, path, fallback) {\r\n        if (!isArray(path)) {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length;\r\n        if (!length) {\r\n          return isFunction(fallback) ? fallback.call(obj) : fallback;\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          var prop = obj == null ? void 0 : obj[path[i]];\r\n          if (prop === void 0) {\r\n            prop = fallback;\r\n            i = length; // Ensure we don't continue iterating.\r\n          }\r\n          obj = isFunction(prop) ? prop.call(obj) : prop;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        allKeys: allKeys,\r\n\r\n        attach : _attach,\r\n\r\n        clone: clone,\r\n\r\n        defaults : createAssigner(allKeys, true),\r\n\r\n        each : each,\r\n\r\n        extend : extend,\r\n\r\n        has: has,\r\n\r\n        isEqual: isEqual,   \r\n\r\n        includes: includes,\r\n\r\n        isMatch: isMatch,\r\n\r\n        keys: keys,\r\n\r\n        mixin: mixin,\r\n\r\n        omit: omit,\r\n\r\n        pick: pick,\r\n\r\n        removeItem: removeItem,\r\n\r\n        result : result,\r\n        \r\n        safeMixin: safeMixin,\r\n\r\n        values: values\r\n    });\r\n\r\n\r\n});"]}