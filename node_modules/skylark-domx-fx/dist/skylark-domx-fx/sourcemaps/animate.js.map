{"version":3,"sources":["animate.js"],"names":["define","langx","browser","noder","geom","styler","eventer","fx","animationName","animationDuration","animationTiming","transitionProperty","transitionDuration","transitionTiming","transitionDelay","animationEnd","normalizeCssEvent","transitionEnd","supportedTransforms","transform","css3PropPrefix","cssReset","normalizeCssProperty","animate","elm","properties","duration","ease","callback","delay","key","endEvent","wrappedCallback","cssValues","cssProperties","transforms","that","this","fired","hasScrollTop","isPlainObject","easing","complete","isString","speeds","undefined","normal","off","isFunction","eace","v","test","top","right","bottom","left","css","size","width","height","push","dasherize","join","event","target","currentTarget","call","on","debounce","clientLeft","scrollToTop"],"mappings":"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","file":"../animate.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./fx\"\r\n], function(langx, browser, noder, geom, styler, eventer,fx) {\r\n\r\n    var animationName,\r\n        animationDuration,\r\n        animationTiming,\r\n        animationDelay,\r\n        transitionProperty,\r\n        transitionDuration,\r\n        transitionTiming,\r\n        transitionDelay,\r\n\r\n        animationEnd = browser.normalizeCssEvent('AnimationEnd'),\r\n        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),\r\n\r\n        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\r\n        transform = browser.css3PropPrefix + \"transform\",\r\n        cssReset = {};\r\n\r\n\r\n    cssReset[animationName = browser.normalizeCssProperty(\"animation-name\")] =\r\n        cssReset[animationDuration = browser.normalizeCssProperty(\"animation-duration\")] =\r\n        cssReset[animationDelay = browser.normalizeCssProperty(\"animation-delay\")] =\r\n        cssReset[animationTiming = browser.normalizeCssProperty(\"animation-timing-function\")] = \"\";\r\n\r\n    cssReset[transitionProperty = browser.normalizeCssProperty(\"transition-property\")] =\r\n        cssReset[transitionDuration = browser.normalizeCssProperty(\"transition-duration\")] =\r\n        cssReset[transitionDelay = browser.normalizeCssProperty(\"transition-delay\")] =\r\n        cssReset[transitionTiming = browser.normalizeCssProperty(\"transition-timing-function\")] = \"\";\r\n\r\n    /*   \r\n     * Perform a custom animation of a set of CSS properties.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} properties\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function animate(elm, properties, duration, ease, callback, delay) {\r\n        var key,\r\n            cssValues = {},\r\n            cssProperties = [],\r\n            transforms = \"\",\r\n            that = this,\r\n            endEvent,\r\n            wrappedCallback,\r\n            fired = false,\r\n            hasScrollTop = false,\r\n            resetClipAuto = false;\r\n\r\n        if (langx.isPlainObject(duration)) {\r\n            ease = duration.easing;\r\n            callback = duration.complete;\r\n            delay = duration.delay;\r\n            duration = duration.duration;\r\n        }\r\n\r\n        if (langx.isString(duration)) {\r\n            duration = fx.speeds[duration];\r\n        }\r\n        if (duration === undefined) {\r\n            duration = fx.speeds.normal;\r\n        }\r\n        duration = duration / 1000;\r\n        if (fx.off) {\r\n            duration = 0;\r\n        }\r\n\r\n        if (langx.isFunction(ease)) {\r\n            callback = ease;\r\n            eace = \"swing\";\r\n        } else {\r\n            ease = ease || \"swing\";\r\n        }\r\n\r\n        if (delay) {\r\n            delay = delay / 1000;\r\n        } else {\r\n            delay = 0;\r\n        }\r\n\r\n        if (langx.isString(properties)) {\r\n            // keyframe animation\r\n            cssValues[animationName] = properties;\r\n            cssValues[animationDuration] = duration + \"s\";\r\n            cssValues[animationTiming] = ease;\r\n            endEvent = animationEnd;\r\n        } else {\r\n            // CSS transitions\r\n            for (key in properties) {\r\n                var v = properties[key];\r\n                if (supportedTransforms.test(key)) {\r\n                    transforms += key + \"(\" + v + \") \";\r\n                } else {\r\n                    if (key === \"scrollTop\") {\r\n                        hasScrollTop = true;\r\n                    }\r\n                    if (key == \"clip\" && langx.isPlainObject(v)) {\r\n                        cssValues[key] = \"rect(\" + v.top+\"px,\"+ v.right +\"px,\"+ v.bottom +\"px,\"+ v.left+\"px)\";\r\n                        if (styler.css(elm,\"clip\") == \"auto\") {\r\n                            var size = geom.size(elm);\r\n                            styler.css(elm,\"clip\",\"rect(\"+\"0px,\"+ size.width +\"px,\"+ size.height +\"px,\"+\"0px)\");  \r\n                            resetClipAuto = true;\r\n                        }\r\n\r\n                    } else {\r\n                        cssValues[key] = v;\r\n                    }\r\n                    cssProperties.push(langx.dasherize(key));\r\n                }\r\n            }\r\n            endEvent = transitionEnd;\r\n        }\r\n\r\n        if (transforms) {\r\n            cssValues[transform] = transforms;\r\n            cssProperties.push(transform);\r\n        }\r\n\r\n        if (duration > 0 && langx.isPlainObject(properties)) {\r\n            cssValues[transitionProperty] = cssProperties.join(\", \");\r\n            cssValues[transitionDuration] = duration + \"s\";\r\n            cssValues[transitionDelay] = delay + \"s\";\r\n            cssValues[transitionTiming] = ease;\r\n        }\r\n\r\n        wrappedCallback = function(event) {\r\n            fired = true;\r\n            if (event) {\r\n                if (event.target !== event.currentTarget) {\r\n                    return // makes sure the event didn't bubble from \"below\"\r\n                }\r\n                eventer.off(event.target, endEvent, wrappedCallback)\r\n            } else {\r\n                eventer.off(elm, animationEnd, wrappedCallback) // triggered by setTimeout\r\n            }\r\n            styler.css(elm, cssReset);\r\n            if (resetClipAuto) {\r\n //               styler.css(elm,\"clip\",\"auto\");\r\n            }\r\n            callback && callback.call(this);\r\n        };\r\n\r\n        if (duration > 0) {\r\n            eventer.on(elm, endEvent, wrappedCallback);\r\n            // transitionEnd is not always firing on older Android phones\r\n            // so make sure it gets fired\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, ((duration + delay) * 1000) + 25)();\r\n        }\r\n\r\n        // trigger page reflow so new elements can animate\r\n        elm.clientLeft;\r\n\r\n        styler.css(elm, cssValues);\r\n\r\n        if (duration <= 0) {\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, 0)();\r\n        }\r\n\r\n        if (hasScrollTop) {\r\n            scrollToTop(elm, properties[\"scrollTop\"], duration, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return fx.animate = animate;\r\n\r\n});"]}